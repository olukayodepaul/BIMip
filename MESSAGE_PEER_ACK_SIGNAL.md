## ‚úÖ MessagePeerAckSignal

The `MessagePeerAckSignal` is the primary acknowledgment signal. It is generated by the server and sent back to the original message sender. It conveys the delivery status and, critically, the **server-generated stream state** via the `Peer` object and the sender's own stream `offset`.

### Protobuf Definition

```protobuf
message MessagePeerAckSignal {
  Identity to = 1;
  Identity from = 2;
  string message_id = 3;
  int32 method = 4;
  int64 timestamp = 5;
  int32 status_code = 6;
  Peer peer = 7;
  int64 offset = 8;  // The sender's global stream offset
}

```

### Field Reference

| Tag | Field Name | Type | Description | Role |
| --- | --- | --- | --- | --- |
| **1** | `to` | `Identity` | The **original message sender** (who receives this ACK). | Routing |
| **2** | `from` | `Identity` | The **server or recipient** identity issuing the acknowledgment. | Routing |
| **3** | `message_id` | `string` | The **ID of the specific `Message**` being acknowledged. | Reference |
| **4** | `method` | `int32` | Operation code (1 = REQUEST, 2 = RESPONSE). | Status |
| **5** | `timestamp` | `int64` | Time the acknowledgment was generated (Epoch milliseconds). | Status |
| **6** | `status_code` | `int32` | **Status code** (e.g., 200 = Success, 409 = Duplicate). | Status |
| **7** | `peer` | `Peer` | **Synchronization Data**. Contains the `peer_offset` and the cross-referenced `to` identity. | Sync |
| **8** | `offset` | `int64` | **Sender Offset**. The message's unique index in the sender's own history. | Sync |

---

### üîÑ Mirror Synchronization (Cross-EID Logic)

The system uses a **Symmetrical Mirror** approach. This ensures that both User A and User B can track the exact same message using their respective perspectives:

#### 1. The Sender's Perspective (User A)

* **Log Entry:** Saved in User A's partition.
* **`offset`:** User A's local sequence number (e.g., `15`).
* **`peer.to`:** Points to **User B**.
* **`peer.peer_offset`:** User B's sequence number (e.g., `82`).
* **Result:** User A knows: *"This is my 15th message, and it is User B's 82nd message."*

#### 2. The Receiver's Perspective (User B)

* **Log Entry:** Saved in User B's partition.
* **`offset`:** User B's local sequence number (e.g., `82`).
* **`peer.to`:** Points to **User A**.
* **`peer.peer_offset`:** User A's sequence number (e.g., `15`).
* **Result:** User B knows: *"This is my 82nd message, and it came from User A's 15th slot."*

---

### üìù Logic Visualization

| Entity | `offset` | `peer.to` | `peer.peer_offset` |
| --- | --- | --- | --- |
| **Sender (A)** | `15` | `EID of B` | `82` |
| **Receiver (B)** | `82` | `EID of A` | `15` |

This "Cross-EID" structure allows the client applications to perform **instant gap detection**. If User B sees a message with `peer.peer_offset: 17` but their last message from User A was `peer.peer_offset: 15`, they know immediately that they missed message `16` from User A and can request a re-sync.

---

### üìù Example Usage (Elixir Implementation)

```elixir
# When User A sends to User B:
ack_for_a = %Bimip.MessagePeerAckSignal{
  to: identity_a,
  message_id: mid,
  status_code: 200,
  offset: 15,          # A's Offset
  peer: %Bimip.Peer{
    to: "b@domain.com",# Link to B
    peer_offset: 82    # B's Offset
  }
}

# The message stored in B's queue would effectively mirror this:
message_in_b_queue = %{
  offset: 82,
  peer: %{to: "a@domain.com", peer_offset: 15}
}

```
