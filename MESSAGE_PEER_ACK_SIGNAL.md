
## ‚úÖ MessagePeerAckSignal

The `MessagePeerAckSignal` is the primary acknowledgment signal. It is generated by the server and sent back to the original message sender. It conveys the delivery status and the **Shared Message Anchor** (`peer_offset`).

### üõ†Ô∏è Protocol Integration (Route 13)

When transmitted over the wire, this signal is wrapped in a `MessageScheme` with **Route 13**.

```elixir
%Bimip.MessageScheme{
  route: 13,
  payload: {:message_peer_ack_signal, %Bimip.MessagePeerAckSignal{
      to: %Bimip.Identity{eid: "a@domain.com"},
      from: %Bimip.Identity{eid: "b@domain.com"},
      message_id: "vcNAQcDoIIB4TCCAd0CAQAxggE2MIIBMgIddd",
      method: 2, # RESPONSE
      timestamp: 1766508129035,
      status_code: 200,
      peer: %Bimip.Peer{
        to: "b@domain.com",
        peer_offset: 1 # The Shared Anchor (Sender's Offset)
      },
      offset: 1 # Physical Local Offset
  }}
}

```

---

### üìò Protobuf Definition

```protobuf
message MessagePeerAckSignal {
  Identity to = 1;
  Identity from = 2;
  string message_id = 3;
  int32 method = 4;
  int64 timestamp = 5;
  int32 status_code = 6;
  Peer peer = 7;
  int64 offset = 8;  // Local physical offset for the Sender
}

```

---

### üîÑ The Anchor-Offset Logic (Shared Reference)

In this architecture, the `peer_offset` acts as the **Global Pointer** for a specific message within a conversation. Regardless of which user is looking at the message, the `peer_offset` remains the same: the **Sender's Offset**.

#### How the Mirror Works:

If **User A** sends a message that the server assigns to User A's **Offset 5**:

1. **For User A (Sender):**
* The `offset` is **5**.
* The `peer.peer_offset` is **5**.
* *Meaning:* "This is my 5th message, and I've anchored it at index 5."


2. **For User B (Receiver):**
* The local `offset` might be **102** (the physical position in B's log).
* The `peer.peer_offset` is **5**.
* *Meaning:* "This is my 102nd message overall, but it is **Message #5 from User A**."



---

### üìù Logic Visualization (Shared Anchor Model)

| Entity | `offset` (Physical Pos) | `peer.to` | `peer.peer_offset` (The Anchor) |
| --- | --- | --- | --- |
| **Sender (A)** | **5** | EID of B | **5** |
| **Receiver (B)** | **102** | EID of A | **5** |

---

### üìò Field Reference

| Tag | Field Name | Type | Description | Role |
| --- | --- | --- | --- | --- |
| **1** | `to` | `Identity` | The **original message sender** receiving this ACK. | Routing |
| **2** | `from` | `Identity` | The server or system identity confirming the write. | Routing |
| **3** | `message_id` | `string` | The unique ID of the message being acknowledged. | Reference |
| **4** | `method` | `int32` | Operation code (See Method Codes below). | Status |
| **5** | `timestamp` | `int64` | Time of generation in epoch milliseconds. | Status |
| **6** | `status_code` | `int32` | **200** for success, **409** for duplicate ID. | Status |
| **7** | `peer` | `Peer` | Contains the `peer_offset` (Shared Anchor). | Sync |
| **8** | `offset` | `int64` | The physical sequence index in the user's log. | Sync |

---

### üö• Method & Status Codes

| Method Value | Name | Description |
| --- | --- | --- |
| **1** | `REQUEST` | Used if a client is requesting an ACK status. |
| **2** | `RESPONSE` | Standard server response after a successful write. |
| **3** | `NACK` | Negative acknowledgment (Permanent failure). |
| **4** | `RETRY` | Server is busy; client should attempt resend. |

| Status Code | Description | Client Action |
| --- | --- | --- |
| **200** | Success | Mark message as sent locally. |
| **409** | Conflict | Message already exists; stop retrying. |
| **500** | Internal Error | Log error and notify user. |

